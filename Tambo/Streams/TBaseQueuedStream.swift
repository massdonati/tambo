//
//  TBaseQueuedStream.swift
//  Tambo
//
//  Created by Massimo Donati on 7/23/18.
//

import Foundation

/// A base class stream that doesn't actually output the log anywhere and is intended to be subclassed
public class TBaseQueuedStream: TStreamProtocol {

    /// private store for the isAsync property.
    private var _async = true

    /**
     Whether we should process the logs asyncronously or no. `true` is the
     default value
     */
    public var isAsync: Bool {
        get {
            return queue.sync { return _async }
        }
        set {
            queue.sync { _async = newValue }
        }
    }
    
    /// Identifier for the stream (should be unique)
    open var identifier: String

    /// Log level for this stream
    open var outputLevel: TLogLevel = .debug

    /// Flag whether or not we've logged the app details to this stream
    open var haveLoggedAppDetails: Bool = false

    public var logFormatter: TLogFormatterProtocol
    /// Array of log filters to apply to messages before they're output
//    open var filters: [FilterProtocol]? = nil

    /// The queue the base stream is serially dispatching to.
    let queue: DispatchQueue

    /**
     Designated initializer.
     - parameter identifier: A unique identifier that will identify the stream.
     - parameter formatterOption: Which log formatter we want to use for this
        stream.
     - parameter queue: The queue all the logging operations will be queued on.
        This doesn't need to be a serial one because the stream will use this
        as a target for its own serial queue.
     */
    public init(identifier: String,
                formatterOption: TLogFormatterOption = .defaultString,
                queue: DispatchQueue? = nil) {
        self.identifier = identifier

        switch formatterOption {
        case .defaultString:
            logFormatter = TLogDefaultStringFormatter()
        case .defaultJSON:
            logFormatter = TLogDefaultJSONFormatter()
        case .custom(let formatter):
            logFormatter = formatter
        }
        // make sure to have a serial queue.
        self.queue = DispatchQueue(
            label: "com.tambo.stream.\(identifier)",
            qos: .background,
            target: queue
        )
    }

    /**
     Formats and outputs the TLog object.
     - parameter log: The [TLog](x-source-tag://T.TLog) object generated by the
        logger.
     */
    public func process(_ log: TLog) {
        let processClosure = {
            let formattedLog = self.logFormatter.format(log)
            self.output(log: log, formattedLog: formattedLog)
        }
        if isAsync {
            queue.async(execute: processClosure)
        } else {
            queue.sync(execute: processClosure)
        }
    }

    /**
     Output the log to the stream i.e. file, backend, db etc.
     - seealso: [TStreamProtocol](x-source-tag://T.TStreamProtocol).
     */
    public func output(log: TLog, formattedLog: Any) {
        precondition(false,
                     "Every subclass needs to override this method.")
    }
}
